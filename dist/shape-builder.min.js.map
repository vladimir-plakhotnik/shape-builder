{"version":3,"file":"shape-builder.min.js","sources":["../src/shapes/Circle.ts","../src/shapes/Point.ts","../src/shapes/Curve.ts","../src/shapes/Line.ts","../src/shapes/Rectangle.ts","../src/shapes/Text.ts","../src/Transform.ts","../src/Builder.ts"],"sourcesContent":["import type { IDraw } from \"../interfaces\";\nimport Point from \"./Point\";\n\n/**\n * Draws a circle in a context\n * @param context Image context\n * @param circleShape Circle shape\n */\nfunction drawingContext(context: CanvasRenderingContext2D, circleShape: Circle): void {\n    context.save();\n\n    if (circleShape.options?.fillColor) {\n        context.fillStyle = circleShape.options.fillColor;\n    }\n\n    if (circleShape.options?.borderColor) {\n        context.strokeStyle = circleShape.options.borderColor;\n    }\n\n    if (circleShape.options?.thickness) {\n        context.lineWidth = circleShape.options.thickness;\n    }\n\n    if (circleShape.options?.dash) {\n        context.setLineDash(circleShape.options.dash);\n    }\n\n    context.beginPath();\n\n    context.arc(\n        circleShape.center.x,\n        circleShape.center.y,\n        circleShape.radius,\n        0,\n        2 * Math.PI,\n        false\n    );\n\n    context.closePath();\n\n    if (circleShape.options?.fillColor) {\n        context.fill();\n    }\n\n    context.stroke();\n\n    context.restore();\n}\n\n/**\n * Creates SVG image code of a circle\n * @param circleShape Circle shape\n * @returns SVG image code of a circle\n */\nfunction svg(circleShape: Circle): string {\n    let circle = `cx=\"${circleShape.center.x}\" cy=\"${circleShape.center.y}\" r=\"${circleShape.radius}\"`;\n\n    if (circleShape.options?.fillColor) {\n        circle += ` fill=\"${circleShape.options.fillColor}\"`;\n    } else {\n        circle += \" fill=\\\"none\\\"\";\n    }\n\n    if (circleShape.options?.borderColor) {\n        circle += ` stroke=\"${circleShape.options.borderColor}\"`;\n    }\n\n    if (circleShape.options?.thickness) {\n        circle += ` stroke-width=\"${circleShape.options.thickness}\"`;\n    }\n\n    if (circleShape.options?.dash) {\n        circle += ` stroke-dasharray=\"${circleShape.options.dash.join(\",\")}\"`;\n    }\n\n    return `<circle ${circle} />`;\n}\n\n/**\n * Circle shape\n */\nexport default class Circle implements IDraw {\n    /**\n     * Creates an instance of a Circle shape\n     * @param center Circle center coordinates\n     * @param radius Circle radius in degrees \n     * @param options Circle drawing options\n     */\n    constructor(\n        public readonly center: Point,\n        public readonly radius: number,\n        public readonly options?: {\n            readonly fillColor?: string,\n            readonly borderColor?: string,\n            readonly thickness?: number,\n            readonly dash?: number[],\n        }\n    ) { }\n    /**\n     * Creates SVG image code of a circle\n     */\n    draw(): string;\n    /**\n     * Draws a circle in a context\n     * @param context Image context\n     */\n    draw(context: CanvasRenderingContext2D): void;\n    draw(context?: CanvasRenderingContext2D): string | void {\n        return context ? drawingContext(context, this) : svg(this);\n    }\n}\n","/**\n * Point object is used to set a coordinate point\n */\nexport default class Point {\n    /**\n     * Creates an instance of a Point\n     * @param x X coordinate\n     * @param y Y coordinate\n     */\n    constructor(public readonly x: number, public readonly y: number) { }\n\n    /**\n     * Adds a point to the current one and returns a new point\n     * @param point A point object\n     * @returns New point\n     */\n    add(point: Point): Point {\n        return new Point(this.x + point.x, this.y + point.y);\n    }\n\n    /**\n     * Subtracts a point from the current one and returns a new point\n     * @param point A point object\n     * @returns New point\n     */\n    subtract(point: Point): Point {\n        return new Point(this.x - point.x, this.y - point.y);\n    }\n}\n","import type { IDraw } from \"../interfaces\";\nimport Point from \"./Point\";\n\n/**\n * Draws a curve in a context\n * @param context Image context\n * @param curve Curve shape\n */\nfunction drawingContext(context: CanvasRenderingContext2D, curve: Curve): void {\n    context.save();\n\n    if (curve.options?.fillColor) {\n        context.fillStyle = curve.options.fillColor;\n    }\n\n    if (curve.options?.borderColor) {\n        context.strokeStyle = curve.options.borderColor;\n    }\n\n    if (curve.options?.thickness) {\n        context.lineWidth = curve.options.thickness;\n    }\n    if (curve.options?.dash) {\n        context.setLineDash(curve.options.dash);\n    }\n\n    const start = new Point(curve.points[0].x, curve.points[0].y);\n\n    context.beginPath();\n\n    context.moveTo(start.x, start.y);\n\n    for (let index = 1; index < curve.points.length; index++) {\n        const point = new Point(curve.points[index].x, curve.points[index].y);\n        context.lineTo(point.x, point.y);\n    }\n\n    if (curve.options?.fillColor) {\n        context.fill();\n    }\n\n    if (curve.options?.borderColor) {\n        context.stroke();\n    }\n\n    context.closePath();\n\n    context.restore();\n}\n\n/**\n * Creates SVG image code of a curve\n * @param curve Curve shape\n * @returns SVG image code of a curve\n */\nfunction svg(curve: Curve): string {\n    let path = `M${curve.points[0].x} ${curve.points[0].y}`;\n\n    for (let index = 1; index < curve.points.length; index++) {\n        path += ` L${curve.points[index].x} ${curve.points[index].y}`;\n    }\n\n    path = `d=\"${path}\"`;\n\n    if (curve.options?.fillColor) {\n        path += ` fill=\"${curve.options.fillColor}\"`;\n    } else {\n        path += \" fill=\\\"none\\\"\";\n    }\n\n    if (curve.options?.borderColor) {\n        path += ` stroke=\"${curve.options.borderColor}\"`;\n    }\n\n    if (curve.options?.thickness) {\n        path += ` stroke-width=\"${curve.options.thickness}\"`;\n    }\n\n    if (curve.options?.dash) {\n        path += ` stroke-dasharray=\"${curve.options.dash.join(\",\")}\"`;\n    }\n\n    return `<path ${path} />`;\n}\n\n/**\n * Curve shape\n */\nexport default class Curve implements IDraw {\n    /**\n     * Creates an instance of a Curve shape\n     * @param points Array of curve coordinate points\n     * @param options Curve drawing options\n     */\n    constructor(\n        public readonly points: Point[],\n        public readonly options?: {\n            readonly fillColor?: string,\n            readonly borderColor?: string,\n            readonly thickness?: number,\n            readonly dash?: number[]\n        }\n    ) { }\n\n    /**\n     * Creates SVG image code of a curve\n     */\n    draw(): string;\n    /**\n     * Draws a curve in a context\n     * @param context Image context\n     */\n    draw(context: CanvasRenderingContext2D): void;\n    draw(context?: CanvasRenderingContext2D): string | void {\n        return context ? drawingContext(context, this) : svg(this);\n    }\n}\n","import type { IDraw } from \"../interfaces\";\nimport type Point from \"./Point\";\n\n/**\n * Draws a line in a context\n * @param context Image context\n * @param lineShape Line shape\n */\nfunction drawingContext(context: CanvasRenderingContext2D, lineShape: Line): void {\n    context.save();\n\n    if (lineShape.options?.color) {\n        context.strokeStyle = lineShape.options.color;\n    }\n\n    if (lineShape.options?.thickness) {\n        context.lineWidth = lineShape.options.thickness;\n    }\n\n    if (lineShape.options?.dash) {\n        context.setLineDash(lineShape.options.dash);\n    }\n\n    context.beginPath();\n\n    context.moveTo(lineShape.start.x, lineShape.start.y);\n\n    context.lineTo(lineShape.end.x, lineShape.end.y);\n\n    context.stroke();\n\n    context.closePath();\n\n    context.restore();\n}\n\n/**\n * Creates SVG image code of a line\n * @param lineShape Line shape\n * @returns SVG image code of a line\n */\nfunction svg(lineShape: Line): string {\n    let line = `x1=\"${lineShape.start.x}\" y1=\"${lineShape.start.y}\" x2=\"${lineShape.end.x}\" y2=\"${lineShape.end.y}\"`;\n\n    if (lineShape.options?.color) {\n        line += ` stroke=\"${lineShape.options.color}\"`;\n    }\n\n    if (lineShape.options?.thickness) {\n        line += ` stroke-width=\"${lineShape.options.thickness}\"`;\n    }\n\n    if (lineShape.options?.dash) {\n        line += ` stroke-dasharray=\"${lineShape.options.dash.join(\",\")}\"`;\n    }\n\n    return `<line ${line} />`;\n}\n\n/**\n * Line shape\n */\nexport default class Line implements IDraw {\n    /**\n     * Creates an instance of a Line shape\n     * @param start Start point coordinate\n     * @param end End point coordinate\n     * @param options Line drawing options\n     */\n    constructor(\n        public readonly start: Point,\n        public readonly end: Point,\n        public readonly options?: {\n            readonly color?: string,\n            readonly thickness?: number,\n            readonly dash?: number[]\n        }\n    ) { }\n\n    /**\n     * Creates SVG image code of a line\n     */\n    draw(): string;\n    /**\n     * Draws a line in a context\n     * @param context Image context\n     */\n    draw(context: CanvasRenderingContext2D): void;\n    draw(context?: CanvasRenderingContext2D): string | void {\n        return context ? drawingContext(context, this) : svg(this);\n    }\n}\n","import type { IDraw } from \"../interfaces/IDraw\";\nimport type Point from \"./Point\";\n\n/**\n * Draws a rectangle in a context\n * @param context Image context\n * @param rectangle Rectangle shape\n */\nfunction drawingContext(context: CanvasRenderingContext2D, rectangle: Rectangle): void {\n    context.save();\n\n    if (rectangle.options?.fillColor) {\n        context.fillStyle = rectangle.options.fillColor;\n    }\n\n    if (rectangle.options?.borderColor) {\n        context.strokeStyle = rectangle.options.borderColor;\n    }\n\n    if (rectangle.options?.thickness) {\n        context.lineWidth = rectangle.options.thickness;\n    }\n\n    if (rectangle.options?.dash) {\n        context.setLineDash(rectangle.options.dash);\n    }\n\n    if (rectangle.options?.fillColor) {\n        context.fillRect(rectangle.coordinates.x, rectangle.coordinates.y, rectangle.width, rectangle.height);\n    }\n\n    if (rectangle.options?.borderColor) {\n        context.strokeRect(rectangle.coordinates.x, rectangle.coordinates.y, rectangle.width, rectangle.height);\n    }\n\n    context.restore();\n}\n\n/**\n * Creates SVG image code of a rectangle\n * @param rectangle Rectangle shape\n * @returns SVG image code of a rectangle\n */\nfunction svg(rectangle: Rectangle): string {\n\n    let x = rectangle.coordinates.x;\n    let width = rectangle.width;\n\n    if (width < 0) {\n        x += rectangle.width;\n        width = Math.abs(width);\n    }\n\n    let y = rectangle.coordinates.y;\n    let height = rectangle.height;\n\n    if (height < 0) {\n        y += rectangle.height;\n        height = Math.abs(height);\n    }\n\n    let rect = `x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\"`;\n\n    if (rectangle.options?.fillColor) {\n        rect += ` fill=\"${rectangle.options.fillColor}\"`;\n    } else {\n        rect += \" fill=\\\"none\\\"\";\n    }\n\n    if (rectangle.options?.borderColor) {\n        rect += ` stroke=\"${rectangle.options.borderColor}\"`;\n    }\n\n    if (rectangle.options?.thickness) {\n        rect += ` stroke-width=\"${rectangle.options.thickness}\"`;\n    }\n\n    if (rectangle.options?.dash) {\n        rect += ` stroke-dasharray=\"${rectangle.options.dash.join(\",\")}\"`;\n    }\n\n    return `<rect ${rect} />`;\n}\n\n/**\n * Rectangle shape\n */\nexport default class Rectangle implements IDraw {\n    /**\n     * Creates an instance of a Rectangle shape\n     * @param coordinates The coordinate of the upper left corner of Rectangle\n     * @param width Rectangle width\n     * @param height Rectangle height\n     * @param options Rectangle drawing options\n     */\n    constructor(\n        public readonly coordinates: Point,\n        public readonly width: number,\n        public readonly height: number,\n        public readonly options?: {\n            readonly fillColor?: string,\n            readonly borderColor?: string,\n            readonly thickness?: number,\n            readonly dash?: number[],\n        }\n    ) { }\n\n    /**\n     * Creates SVG image code of a rectangle\n     */\n    public draw(): string;\n    /**\n     *  Creates SVG image code of a rectangle\n     * @param context Image context\n     */\n    public draw(context: CanvasRenderingContext2D): void;\n    public draw(context?: CanvasRenderingContext2D): string | void {\n        return context ? drawingContext(context, this) : svg(this);\n    }\n}\n","import { IFontStyle, IDraw } from \"../interfaces\";\nimport type Point from \"./Point\";\n\n/**\n * Draws a text in a context\n * @param context Image context\n * @param textShape Text shape\n */\nfunction drawingContext(context: CanvasRenderingContext2D, textShape: Text): void {\n    context.save();\n\n    if (textShape.options?.color) {\n        context.fillStyle = textShape.options.color;\n    }\n\n    if (textShape.options?.font) {\n        context.font = Text.fontStyleToString(textShape.options.font);\n    }\n\n    if (textShape.options?.text) {\n        context.textAlign = textShape.options.text.align;\n        context.textBaseline = textShape.options.text.baseline;\n    }\n\n    if (textShape.options?.rotate) {\n        context.translate(\n            textShape.coordinates.x,\n            textShape.coordinates.y\n        );\n        context.rotate(textShape.options.rotate * Math.PI / 180);\n        context.fillText(\n            textShape.text,\n            0,\n            0\n        );\n    } else {\n        context.fillText(\n            textShape.text,\n            textShape.coordinates.x,\n            textShape.coordinates.y\n        );\n    }\n    context.restore();\n}\n\n/**\n * Creates SVG image code of a text\n * @param textShape Text shape\n * @returns SVG image code of a text\n */\nfunction svg(textShape: Text): string {\n    let text;\n\n    if (textShape.options?.rotate) {\n        text = `x=\"0\" y=\"0\" transform=\"translate(${textShape.coordinates.x}, ${textShape.coordinates.y}) rotate(${textShape.options.rotate})\"`;\n    } else {\n        text = `x=\"${textShape.coordinates.x}\" y=\"${textShape.coordinates.y}\"`;\n    }\n\n    if (textShape.options?.color) {\n        text += ` fill=\"${textShape.options.color}\"`;\n    }\n\n    if (textShape.options?.font?.family) {\n        text += ` font-family=\"${textShape.options.font.family}\"`;\n    }\n\n    if (textShape.options?.font?.size) {\n        text += ` font-size=\"${textShape.options.font.size}\"`;\n    }\n\n    if (textShape.options?.font?.style) {\n        text += ` font-style=\"${textShape.options.font.style}\"`;\n    }\n\n    if (textShape.options?.font?.weight) {\n        text += ` font-weight=\"${textShape.options.font.weight}\"`;\n    }\n\n    if (textShape.options?.font?.variant) {\n        text += ` font-variant=\"${textShape.options.font.variant}\"`;\n    }\n\n    if (textShape.options?.font?.stretch) {\n        text += ` font-stretch=\"${textShape.options.font.stretch}\"`;\n    }\n\n    if (textShape.options?.font?.kerning) {\n        text += ` font-kerning=\"${textShape.options.font.kerning}\"`;\n    }\n\n    // text align\n\n    switch (textShape.options?.text?.align) {\n    case \"center\":\n        text += \" text-anchor=\\\"middle\\\"\";\n        break;\n    case \"right\":\n    case \"end\":\n        text += \" text-anchor=\\\"end\\\"\";\n        break;\n    default:\n        text += \" text-anchor=\\\"start\\\"\";\n    }\n\n    // text baseline\n\n    switch (textShape.options?.text?.baseline) {\n    case \"top\":\n    case \"hanging\":\n        text += \" dominant-baseline=\\\"hanging\\\"\";\n        break;\n    case \"alphabetic\":\n        text += \" dominant-baseline=\\\"alphabetic\\\"\";\n        break;\n    case \"ideographic\":\n        text += \" dominant-baseline=\\\"ideographic\\\"\";\n        break;\n    case \"middle\":\n        text += \" dominant-baseline=\\\"middle\\\"\";\n        break;\n    default:\n        text += \" dominant-baseline=\\\"auto\\\"\";\n    }\n\n    return `<text ${text}>${textShape.text}</text>`;\n}\n\n/**\n * Text shape\n */\nexport default class Text implements IDraw {\n    /**\n     * Creates an instance of a Text shape\n     * @param coordinates Text coordinates in a image\n     * @param text Text to draw in an image\n     * @param options Text drawing options\n     */\n    constructor(\n        public readonly coordinates: Point,\n        public readonly text: string,\n        public readonly options?: {\n            readonly color?: string,\n            readonly font?: IFontStyle,\n            readonly text?: {\n                align: CanvasTextAlign,\n                baseline: CanvasTextBaseline,\n            },\n            readonly rotate?: number\n        }\n    ) { }\n\n    /**\n     * Creates SVG image code of a text\n     */\n    draw(): string;\n    /**\n     * Creates SVG image code of a text\n     * @param context Image context\n     */\n    draw(context: CanvasRenderingContext2D): void;\n    draw(context?: CanvasRenderingContext2D): string | void {\n        return context ? drawingContext(context, this) : svg(this);\n    }\n\n    /**\n     * Measures a text\n     * @param context The image context\n     * @param text Text to draw in the image\n     * @param font Font description\n     * @returns A {@link https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics TextMetrics} object \n     */\n    static measure(\n        context: CanvasRenderingContext2D,\n        text: string,\n        font?: IFontStyle\n    ): TextMetrics {\n        if (font) {\n            context.save();\n            context.font = Text.fontStyleToString(font);\n        }\n\n        const result = context.measureText(text);\n\n        if (font) {\n            context.restore();\n        }\n\n        return result;\n    }\n\n    /**\n     * Fits a text into a box \n     * @param context The image context\n     * @param text Text to draw in a box\n     * @param boxSize Size of box in image\n     * @param font Font description\n     * @returns Font size to fit a text into a box\n     */\n    static fitIntoBox(\n        context: CanvasRenderingContext2D,\n        text: string,\n        boxSize: { width: number, height: number },\n        font?: IFontStyle\n    ): number {\n        context.save();\n\n        if (font) {\n            context.font = Text.fontStyleToString(font);\n        }\n\n        const fontString = context.font.split(\" \");\n\n        const index = fontString.findIndex(item => /\\d+px/.test(item.trim()));\n\n        if (index === -1) {\n            throw new Error(\"Font size does not found in an image context\");\n        }\n\n        let number = parseInt(fontString[index]);\n\n        if (!number) {\n            throw new Error(\"Font size does not found in an image context\");\n        }\n\n        const updateFont = () => {\n            fontString[index] = `${number}px`;\n            context.font = fontString.join(\" \");\n        };\n\n        const getTextWidth = (text: string) => context.measureText(text).width;\n\n        const getTextHeight = (text: string) => context.measureText(text).actualBoundingBoxAscent + context.measureText(text).actualBoundingBoxDescent;\n\n        if (getTextWidth(text) > boxSize.width || getTextHeight(text) > boxSize.height) {\n            // decrease            \n            while (getTextWidth(text) > boxSize.width || getTextHeight(text) > boxSize.height) {\n                number--;\n                updateFont();\n            }\n        } else {\n            // increase\n            while (getTextWidth(text) < boxSize.width && getTextHeight(text) < boxSize.height) {\n                number++;\n                updateFont();\n            }\n            if (getTextWidth(text) > boxSize.width || getTextHeight(text) > boxSize.height) {\n                number--;\n            }\n        }\n\n        context.restore();\n\n        return number;\n    }\n\n    /**\n     * Converts font style object to string\n     * @param fontStyle Font style object\n     * @returns Font style string\n     */\n    static fontStyleToString(fontStyle: IFontStyle): string {\n        let font = \"\";\n        if (fontStyle.style) {\n            font = `${fontStyle.style} `;\n        }\n        if (fontStyle.variant) {\n            font += `${fontStyle.variant} `;\n        }\n        if (fontStyle.weight) {\n            font += `${fontStyle.weight} `;\n        }\n        if (fontStyle.stretch) {\n            font += `${fontStyle.stretch} `;\n        }\n        if (fontStyle.size) {\n            font += `${fontStyle.size} `;\n        }\n        if (fontStyle.lineHeight) {\n            font += `${fontStyle.lineHeight} `;\n        }\n        if (fontStyle.family) {\n            font += `${fontStyle.family}`;\n        }\n        return font.trim();\n    }\n}\n","/**\n * Transform Record Object\n */\nexport default class Transform {\n\n    constructor(public readonly object: Record<string, unknown>) { }\n\n    /**\n     * Filters properties\n     * @param properties Array of excluded properties\n     * @returns Filtered object\n     */\n    exclude(properties: string[]): Record<string, unknown> {\n        return Object.keys(this.object)\n            .filter((property) => !properties.includes(property))\n            .reduce((result, property) => {\n                result[property] = this.object[property];\n                return result;\n            }, {} as Record<string, unknown>);\n    }\n\n    /**\n     * Filters properties\n     * @param properties List of allowed properties\n     * @returns Filtered object\n     */\n    include(properties: string[]): Record<string, unknown> {\n        return Object.keys(this.object)\n            .filter((property) => properties.includes(property))\n            .reduce((result, property) => {\n                result[property] = this.object[property];\n                return result;\n            }, {} as Record<string, unknown>);\n    }\n\n    /**\n     * Stringify object\n     * @returns Text\n     */\n    stringify(): string {\n        let result = \"\";\n        for (const property in this.object) {\n            result += `${property}:${this.object[property]}; `;\n        }\n        return result.trim();\n    }\n\n    /**\n     * Stringify object values\n     * @returns Text\n     */\n    values(): string {\n        let result = \"\";\n        for (const property in this.object) {\n            result += `${this.object[property]} `;\n        }\n        return result.trim();\n    }\n\n    /**\n     * Parses text\n     * @param text Source text\n     * @returns Parsed object\n     */\n    static parse(text: string): Record<string, unknown> {\n        const pairs = text.trim().split(\";\").map(item => item.trim());\n        const object: Record<string, unknown> = {};\n        for (const pair of pairs) {\n            const [key, value] = pair.split(\":\").map(item => item.trim());\n            object[key] = value;\n        }\n        return object;\n    }\n}\n","import type { IBuilder, IDraw } from \"./interfaces\";\n\n/**\n * Shape builder\n */\nexport default class Builder implements IBuilder {\n\n    private shapes: IDraw[] = [];\n\n    /**\n     * Creates an instance of a shape builder\n     * @param shapes Shape array\n     */\n    constructor(shapes?: IDraw[]) {\n        if (shapes) {\n            this.shapes = shapes;\n        }\n    }\n\n    /**\n     * Adds a shape\n     * @param shape A shape\n     * @returns The shape builder\n     */\n    addShape(shape: IDraw) {\n        this.shapes.push(shape);\n        return this;\n    }\n\n    /**\n     * Adds a lot of shapes\n     * @param shapes The shapes\n     * @returns The shape builder\n     */\n    addShapes(...shapes: IDraw[]) {\n        this.shapes.push(...shapes);\n        return this;\n    }\n\n    /**\n     * Remove shapes from a shape builder\n     * @param quantity A quantity of shapes. Removes all shapes if the quantity is skipped\n     * @returns The shape builder\n     */\n    removeShapes(quantity?: number) {\n        if (quantity && this.shapes.length > quantity) {\n            this.shapes = this.shapes.slice(0, this.shapes.length - quantity);\n        } else {\n            this.shapes = [];\n        }\n        return this;\n    }\n\n    /**\n     * Creates SVG image code \n     * @param width Image width\n     * @param height Image height\n     */\n    draw(width: number, height: number): string;\n    /**\n     * Draws image in context\n     * @param context Image context\n     */\n    draw(context: CanvasRenderingContext2D): void;\n    draw(widthOrContext: number | CanvasRenderingContext2D, height?: number): string | void {\n\n        if (typeof widthOrContext === \"function\" || typeof widthOrContext === \"object\") {\n            return this.shapes.forEach(shape => shape.draw(widthOrContext));\n        }\n\n        if (typeof widthOrContext === \"number\" && typeof height === \"number\") {\n            return `<svg width=\"${widthOrContext}\" height=\"${height}\">\\n${this.shapes.map(item => item.draw()).join(\"\\n\")}\\n</svg>`;\n        }\n\n        throw new TypeError(\"Wrong arguments.\");\n    }\n}\n"],"names":["Circle","center","radius","options","this","prototype","draw","context","circleShape","save","_a","fillColor","fillStyle","_b","borderColor","strokeStyle","_c","thickness","lineWidth","_d","dash","setLineDash","beginPath","arc","x","y","Math","PI","closePath","_e","fill","stroke","restore","drawingContext","circle","concat","join","Point","add","point","subtract","Curve","points","curve","start","moveTo","index","length","lineTo","_f","path","svg","Line","end","lineShape","color","line","Rectangle","coordinates","width","height","rectangle","fillRect","strokeRect","abs","rect","textShape","font","Text","fontStyleToString","text","textAlign","align","textBaseline","baseline","rotate","translate","fillText","family","size","_h","_g","style","_k","_j","weight","_m","_l","variant","_p","_o","stretch","_r","_q","kerning","_t","_s","_v","_u","measure","result","measureText","fitIntoBox","boxSize","fontString","split","findIndex","item","test","trim","Error","number","parseInt","updateFont","getTextWidth","getTextHeight","actualBoundingBoxAscent","actualBoundingBoxDescent","fontStyle","lineHeight","Transform","object","exclude","properties","_this","Object","keys","filter","property","includes","reduce","include","stringify","values","parse","pairs_1","map","_i","key","value","Builder","shapes","addShape","shape","push","addShapes","arguments","apply","removeShapes","quantity","slice","widthOrContext","forEach","TypeError"],"mappings":"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"}